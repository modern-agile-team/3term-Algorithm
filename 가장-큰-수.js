function solution(numbers) {
  let answer = numbers
    .map((num) => String(num).repeat(4))
    .sort()
    .reverse()
    .map((num) => num.slice(0, num.length / 4))
    .join("");
  return answer[0] === "0" ? "0" : answer;
}
/*
메소드를 사용한 풀이
우선 이 문제의 포인트는 위에서 언급한 것과 같이 숫자를 문자로 만들고, 문자열의 첫번째 자리가 같을 때 숫자의 앞뒤 위치를 판단하는 부분이다.
a,ab의 비교를 예시로 생각 해보았을 때, a가 b보다 큰 경우 aab, a가 b보다 작은 경우 aba 이런 순서로 순서를 정해 주어야 한다.
두개의 숫자의 순서를 정해주는 방법
=
비교해주어야 하는 부분까지의 길이를 같게 만들어 주고 (a를 aa로 문자열 정렬인 sort를 이용하여 aa와 ab를 비교하면 된다.
문제에서 배열에 주어지는 숫자의 값은 0-1000까지라고 했으므로 모든 숫자를 repeat 메소드를 사용해 "최소" 4자리로 만들어주고 문자열 정렬을 해준다면
[3,20,5,80,99,300] > [3333,20202020,5555,80808080,99999999,300300300300] > [20202020,300300300300,3333,5555,80808080,99999999] 이런식으로 
배열이 변화할 것이고, 배열의 요소들을 다시 4로 나누어 원본의 크기를 맞춰주면 [20,300,3,5,80,99] 라는 배열이 나오게 되고, 이 배열을 reverse메소드를 사용해
뒤집은 이후 join으로 병합해준다면 원하는 정답이 나올 것이다.
*/

/*
문제를 처음 접했을때 했던 생각
1. 문자열 정렬인 sort를 sort((a,b) => a-b) 이런 식으로 사용하지 않고 해야함 (그래야 6 이 10보다 큰수로 판정할 수 있음)
2. 문자열을 합칠 때 3 이 30 보다 앞에 와야함
3. 6 ,69 이렇게 되면 696 이렇게 나와야 함 > 아.... a, ab 이렇게 주어졌을때 a > b 경우에만 aab로 배정 a < b 경우 aba로 고고
4. 각 숫자의 자리수가 다른데 이는 어떻게 해결할 것인가? >> 자릿수를 맞춰 주어야 한다.
5. 대박!! 자릿수만 맞춰주게 되면 sort정렬을 통해 알아서 문자열 정렬이 된다.
6. 배열의 값이 0으로만 주어졌을 때는 어떻게 해결해야 하는가?
*/

/*
 재귀적 사고 도입 
반복적인 작업이 생기는 부분 찾기 > 두개의 숫자의 순서를 비교할 때 반복으로 확인해야하는 작업이 생긴다
반복적인 작업은? > 두개의 숫자를 비교할 때 두개의 숫자의 앞자리가 같다면? 비교해줄 두 숫자가 몇자리 숫자냐에 따라 작업 루틴이 바뀜
3,30이 비교된다면 3 이 30보다 앞에와야함 3,34가 비교된다면 34가 3보다 앞에 와야함
재귀 함수를 만들어서 두 숫자를 비교할 때, 재귀함수를 사용하게끔 하면 가능할 수도?
그렇다면 재귀적인 반복이 종료되는 조건은 무엇인가? > 더이상 비교할 값이 없을 때!
*/

/*
이 문제를 재귀함수로 풀지 못하는 이유?
우선 숫자가 100,000 개나 주어질 수 있기 때문에 재귀탐색을 통해 문자열 조합,비교는 힘들다.
또한 재귀적으로 푼다고 하더라도 비교 하는 두 수의 자릿수를 맞춰가면서 비교해주어야 하기 때문에 어려움이 있다.
*/
